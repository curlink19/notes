Стариков Никита Юрьевич - Лектор из 1С. Окончил МФТИ.
Санду Роман - Рома Семинарист.

Оценка за лекции = 0.3 * Промежуточная(апрель) + 0.7 * Финальная(май)
Оценка за курс = f(оценка за лекции, оценка за семинар, оценка за прак. задания)
Финальная контрольная - важна, без неё пересдача.

Лекция 1. Проектирование ПО.

----Критерии хорошего проектирования.

Эффективность системы.
	Надёжность - безошибочность действий
	Безопасность - безопасность любого вида данных
	Производительность - могут быть разные метрики
	Масштабируемость. 
P.S. Будем говорить о софте с высокой степени ответственности - банк, медицина, безопасность.

Принцип YAGNI - you aren't gonna need it - не делай то, что никогда не понадобится
Принцип KISS - keep it simple stupid - решай требуемую задачу максимально просто
	Не всегда следует делать какие-нить шаблоны-хуйоны, это усложняет процесс и поддержку кода.

Гибкость системы.
	Изменения текущей функциональности
	Исправления ошибок
	Настройка системы
		Под пользователя - софт должен меняться легко
		Под разные задачи
Для таковой гибкости нужно разбираться в предметной области.

Расширяемость системы - возможность добавлять новые сущности и функции
	P.S. Внесение наиболее вероятных изменений должно требовать наименьших усилий.

Ещё критерии.
	Масштабируемость процесса разработки. - разработчики должны делать своё дело и не тратить время на договоры по ходу.
	Тестируемость.
	Возможность повторного использования. - в других сервисах / проектах.
	Сопровождаемость. - возможность поддержки софта, который вы написали

----Критерии неудачной архитектуры

Жёсткость - тяжело изменить
Хрупкость - изменения нарушают другие модули
	Часто сопровождает legacy-проекты. Это проекты, которые были написаны супер-пупер давно, но используется.
	Это то, с чем приходится мириться, т.к. тормозит проект на пару лет, когда нужно переписать весь legacy
Неподвижность - тяжело извлечь модуль наружу.


----High cohesion / Low coupling
High cohesion
	Высокая сопряжённость внутри модуля.
	Модуль сфокусирован на решении одной задачи.
Low coupling
	Слабая связь между модулями
	Связи строго регламентированы
5 принципов SOLID
1) S - Single-responsibility principle
	Принцип единственной ответственности - класс должен иметь лишь одну ответсвенность
	и эта ответсвенность должна быть полностью инкапсулирована в класс.
2) O - Open-closed principle
	Открыт для расширения, закрыт для изменения - всё логично.
3) L - Liskov substitutional principle
	Объект ребёнка можно подставить вместо объекта родителя(имеется ввиду, что это должно быть логично).
4) I - Interface segregation principle
	Принцип разделения интерфейсов - Много интерфейсов, специально предназнаечнных для разных клиентов лучше,
	чем один интерфейс общего назначения.
5) D - Dependency inversion principle
	Принцип обращения зависимостей - зависимости на абстракциях, а не на реализациях.
	Это значит, что делаем абстрактные классы, у которых фикс. названия функций,
	и зависимости строим на этих названиях. Реализации могут меняться, но всё будет работать, хрупкость низкая.
Закон Деметры - принцип минимального знания.
Объект А не должен иметь непоср. доступа к объекту С, если у объекта А есть доступ к промежуточному объекту В,
а у объекта В есть доступ к объекту С

YAGNI - you ain't gonna need it
	Не делай того, что никому не нужно(что тебе никогда не понадобится)

DRY - don't repeat yourself
	в случае нахождения ошибки - проще её исправить в одном месте
DRY = DIE = duplication is evil

KISS - keep it simple, stupid
	нет смысла делать что-то красивое, ради того, чтобы сделать что-то красивое

*******Методы отладки ПО********

Процесс отладки. Основные этапы.
- Воспроизведение дефекта (по описанию дефекта пользователем)
- Анализ дефекта
- Дизайн исправления дефекта
- Исправлние дефекта
	В дополнение в проектах:
- Валидация исправления
- Интеграция исправления в код или целевую систему
	"У меня работает" - т.е. на машине работает, а у клиента нет

Чуть подробнее о каждом.

Воспроизведение деффекта.
	Необходимости:
	- Точное соответствие версии (с точностью до билда).
		Решение: использование логов.
	- Точное соответствие настроек (вдруг ошибка наблюдается только в конкретном случае машины пользователя)
		Решение: использование логов, с целью собирать данные ПК юзера.
	- Данные, на которых наблюдалась проблема.
		Нельзя просто логировать персональные данные юзера - это не хорошо:(
		Решение: Можно данные обфусцировать - например строку переводить в хэш.
		Часто пользователь не согласится с отправкой персональных данных.
	- Точное воспроизведение действий / сценария
		Решение: логирование всех действий юзера.
			Это также такая себе идея, т.к. юзер не согласится
				Решение: логировать вызов функций, а не действий пользователя
			Большой объём данных.
				Решение: сохранение 5 минут логов.
				Другое решение: в момент когда пользователь получает ошибку - попросить его
						повторить действия со вкл. логами.

Анализ дефекта.
	Важные аспекты:
	- Поиск root-cause
		В чём корневая проблема?
		В больших проектах поиск root-cause - очень сложная задача, так что иногда решают следствие:(
	- Условия возникновения:
		Чётко сформулированные критерии:
		Полные, однозначные.
		Ахтунг: обращать внимание на настройки по умолчанию, т.к. на польз. машине они могут быть поменяны,
			а разработчик даже не думает об этой настройке, как о "переменной в уравнении"
		
		Плохой пример условий возникновения: ошибка при данных настройках возникает каждый второй раз.
			Пример проблемы, скрывающейся: переполняется кэш.
			Решение: увеличить кэш в 100 раз
			Валидация решения: запустили 10 раз, ошибка не возникла.
			Реальность: ошибка возникает теперь каждый 200-ый раз, проблема не решена.
	- Область повреждения:
		Вопросы которые стоит себе задать:
			Что именно сломано?
			Какой основной сценарий(ии)? - сообщён пользователем.
			Есть ли дополнительные сценарии? - поиск разрабом.
			Может ли ещё на что-то повлиять? - вдруг исправление бага убъёт код другого человека
	- Кто привнёс?
		Т.е. как ошибка смогла дойти до юзера - разраб перегружен, тестировщик лох,
							на малой группе плохо проверили - исправить алгоритм провер.
	- В какой версии появилась?
		Т.е. поддержка старых версий - стоит выпускать поддержку старых версий редко, т.к. 
		иногда обновление - это большие сложности.

Дизайн исправления дефекта
	- Технический дизайн, т.е. как мы поменяем код в конкр. месте(ошибка типа поменяли знак минуса)
	- Архитектурныей, т.е. бизнес - логика проекта неверна(вы думали что мир как-то по другому работает)
	- Технологический - например изменение провайдера, который плохо присылает смски
			Переход на другую технологию.
	
	- Ревью и согласование решений - обязательно!

Исправлние дефекта.
	- Не привнести новые дефекты
		Анекдот: было 2 ошибки, исправили 2 ошибки, нашли ещё 2 ошибки, стало 5 ошибок.
		Хаха 2 + 2 = 5
	- Ожидаемое поведение и логика
		Ожидаемое для пользователя, а не для вас - т.е. чтобы юзер понял то, что произошло
	- Костыли и грязные хаки
		Когда решили проблему так, как получилось.
	- Документирование

Валидация исправления.
	- Проверка исходного сценария
	- Проверка всех сценариев возникновения
	- Проверка связанных сценариев
	- Полноценное тестирование системы.
		Night build - сборка проекта и прогон теста ночью, чтобы не тратить время рабочее.

Интергация исправления в код или целевую систему.
	- Слитие со стволом.
	- Проверка сборки и работоспособности
	- Деплоинг новой версии в целевую систему - процесс установки вашего софта на конкр. систему в боевой режим
	- Обновление серверной/пользовательской систем
	- Документация

Доп. валидации после интеграции
	- Проверка сценариев ошибки
	- Проверка связанных сценариев
	- Полноценная проверка системы
	- Проверка устойчивости работоспособности всех версий
	- Проверка корректности обновления.
Техники отладки ПО.

Стандартные:
- Трассировка: Запуск программ в отладчике
    - Софтверный - в IDE дебуг
    - Железный (хардварный) - подключение платы с проверкой настроек
    - Удалённый дебаггер - отладка удалённого серва
- Логирование:
    - Работы системы. То какие действия происходили в реале.
    - Программного кода. То какие функции вызывались.
- Анализ программного кода без исполнения программы:
    - Метод пристального взгляда
    - Статические анализаторы - делают предупреждения на конкретных местах в коде.
        Шаблоны тяжело анализировать, например
- Анализ поведения системы
    - Упрощение ошибочного сценария до тривиального, без потери ошибочности
    - Ограничение объёма данных
    - Упрощение данных / запроса
- UNIT - тестирование
    Написание тестов на каждую конкретную функцию.
- Прототипирование
    Проблема возникает, если воспроизведение сценария занимает много времени.
    Решение: создание мини-софта, который восстанавливает сценарий вплоть до ключевого момента.
- Отладка с помощью дампов.
    Дамп - файл, где сохранено состояние оперативной памяти вашей программы.
    Этот файл можно открыть и посмотреть состояние программы.
    Зачем? А вдруг у юзера чё-то говнится, а у тебя нет. Он присылает тебе дамп, ты восстанавливаешь это говно.
- Отладка с помощью перехватов.
    Позволяет олтследить вызовы функций.
- Профилирование кода.
    Некоторый софт в IDE, в котором можно видеть потребляемые ресурсы.
    Помогают в решении проблем с оптимизацией.
    - Помогает ловить и обосновывать зависание системы
    - Помогает ловить утечки памяти
- Выполнение кода в другой среде.
- Отладка методом RPC
    (remote procedure call) - т.е. вызов функций на удалённом устройстве с возвратом ответа
- Отладка путём анализа документации, проектных документов и т.д.
    Т.е. если ошибка на уровне понимания алгоритма работы с внешними системами.
- Отладка трансляцией кода
    - Трансляция "вниз" (Просто делать)
        Получаем, например, ассемблерный код, который вдруг можно будет проще понять
    - Трансляция "вверх" (Сложно делать)
        Получаем С++ шный код, который куда проще анализировать.
- Отладка разработкой интерпретатора
    - Каво-таво
- Метод индукции (от частного к общему).
    - Подставляем маленькие ситуации
- Метод дедукции (от общего к частному)
    - Уменьшаем область поиска ошибки.
- Обратное движение по алгоритму.
    - Пусть ошибка в строке X, посмотрим какие строки формируют результат в строке X, это: X - k1, X - k2, ...
    и т.д.

Пример: с Пунто-свитчером - заменителем инглиша на рашан.
 
Этапы развития проекта(1).

1. Формирование требований
2. Разработка концепции(как это примерно выглядит).
3. Техническое задание.
4. Эскизный проект
5. Технический проект
6. Рабочая документация
7. Ввод в действие
8. Сопровождение

В предположении того, что мы все этапы совершаем сами.

1) Формирование требований.
    - Общение с клиентом
    - Общение с пользователем (важно, т.к. клиент не всегда понимает как правильно)
    - Анализ предметной области
    - Формирование оценок качества
    
    - Обследование объекта. - узнаём место с каким оборудованием будем работать(пример - Гидроэлектростанция и датч)
    - Обоснование необходимости создания (какую проблему пользователя будем решать).
    - Формирование требований пользователя (формально описать что будет хотеть юзер для создания тестов).
    - Подготовка отчётности по этапу.

2) Разработка концепции.
    - Изучение объекта автоматизации
    - Проведение необходимых НИР(науч.-иссл. работы)(например при разработке прилож -
                                        оценка нагруж. системы, выбор эффективных алгоритмов)
    - Разработка вариантов концепции(вероятно создать несколько концепций)
    - Подготовка отчётности по этапу.
    
    Что нужно понять по итогу этапа?
    - Выбор формата поставки(андроид/ПК приложение)
    - Целевое оборудование(пример - версия андроида / хар-ки оборудования на заводе)
    - Построение высокоуровневой архитектуры системы(например где будет выполняться больш. вычислений: клиент/серв)
    - Выбор/разработка новых алгосов/технологий

3) Техническое задание.(есть ГОСТы)
    Что там должно быть:
    - Описание системы(в общих чертах чё это)
    - Описание функциональности приложения.
    - Описание требований к приложению.
    - Описание сценариев использования(что пользователь должен уметь делать)
    - Условия сдачи - что нужно сделать, чтобы окончить работу(важно).

4) Эскизный проект:
    - Разработка прототипов частей системы
    - Тестирование
    - Оценка произв. и качества от юзеров
    - Изменение прототипов
    - Отчёт по этапу.

    - Очень часто это MVP(minimum viable project).
    - Иногда это система с базовой функциональностью
    - Иногда - система с урезанным контентом
    - Иногда - менее производительная(чаще идёт вдобавок к предыдущ. двум)    

5) Технический проект:
    - Разработка частей системы
    - Разработка документации
    - Разработка заданий на проектирование и реализацию смежных систем
    - Тестирование
    - Оценка качества и производительности

6) Рабочая документация:
    - Сценарии использования
    - Описание логики работы
    - Описание производительности
    - Примеры использования
    - Обучающие мероприятия(персонала/юзеров)

7) Ввод в действие(под заказчика)
    - Подготовка объекта автоматизации
    - Подготовка персонала
    - Комплектация системы посталяемые изделиями
    - Проведение предварительных испытаний
    - Опытная эксплуатация
    - Приёмочные испытания
    - Внедрение софта(в случае тиражного софта)

8) Сопровождение системы(можно сделать бизнес на таком)
    - Гарантийные обязательства
    - Послегарантийное обслуживание
Диаграммы UML. 2ая лекция в рамках темы "Процесс разработки ПО"
UML - unified modeling language.

Есть элементы, связи.
Есть правила "рисования" - нотация. Если соблюдать все правила - можно даже 
При том можно пренебрегать нотацией, чтобы упрощать процесс проектирования и более удобной коммуникации.

1) Диаграмма вариантов использования
На диаграмме есть actor-ы(могут быть не только люди, но и сторонние сервисы) -
    - те, кто и как используют наш сервис.
Стрелочки = соединители.
a -> b (<<extend>>) - действие а (опционально) расширяет действие b.
a -> b (<<include>>) - действие а включает в себя действие b.(обязательно)

2) Диаграмма классов
Прямоугольнички - классы
Название сверху.
    Если класс абстрактный - писать курсивом.
Поля ниже.
+ public
- private
# protected
Методы ниже.
+ smth: return type

Соединитель(без стрелочек) -(о принадлежности) с циферками около каждого класса(около банка +1, около польз +1..*)

Соединитель(пустая стрелочка) - наследование от наследника к родителю.

3) Диаграмма последовательности.
Две вертикальных прямых(линии жизни).
Там где прямоугольники на линиях жизни - происходит нек. процесс.
Линии жизни общаются друг с другом некоторыми методами (стрелочки вправо/влево).

4) Диаграммы состояний.
Каждый блок - состояние системы. Между блоками методы, которые переводят систему из одного состояния в другой.
Похожу на блок схему.

5) Диаграмма деятельности
Опять похоже на блок схему, где описаны вызовы функций в тех или иных случаях.
Начальная и терминальная вершины, как кружок и кружок с каёмкой.

Далее примеры:
Из диаграммы вариантов использования не виден тайм-лапс. Поэтому используем диаграмму деятельности.
25/03 - промежуточная контрольная.
Даёт 30% от оценки.
Содержание - все вопросы, осмотренные на лекциях.

Процесс разработки ПО(3).
Методологии разработки ПО - Подход к организации работы/

- Выбор методолгии зависит от многих параметров(как внутренних, так и внешних)
    - Особенности проекта
        - Сроки
        - Бюджет
        - Вариант поставки
        - Требования к качеству
        - ...
    - Особенности команды
    - Особенности заказчика

Примеры методолгий разработки ПО
- Какадная (она же Waterfall)
- V-модель
- Инкрементная модель
- Спиральная модель
- RAD-модель
- Семейство гибких методолгий(adjile?)
    - Scrum
    - Kanban
    - Lean
    ...


1) Каскадная модель
Разбиваем процесс на стадии. Последовательно их проходим. Стадия не начинается, пока не закончится предыдущ.
- Чёткие:
    - Сроки
    - Стоимость
    - Результат
Т.е. знаем промеж. результат в любой момент. - и это плюс.
- Но есть и минусы:
    Совершенно не гибкая модель. Если заказчик придёт с изменениями, то придётся перепиливать всё заново.
    При больших проектах это нежизнеспособно, т.к. там часто процессы идут параллельно.
Как это визуализировать - диаграмма Ганта.

2) V - модель.
Проект снова разбивается на некоторые этапы, которые затем рисуются в форме буквы V.
Левая ветвь - верификация, правая - валидация.
Этапы с левой ветви связаны с этапами правой(ака биекция).

Верификация:
    - Общая концепция
    - Требования бизнеса
    - Функциональные требования
    - Архитектура
    - Реализация
Валидация:
    - Приёмо-сдаточное тестирование
    - Функциональное тестирование
    - Интеграционное тестирование 
    - Модульное тестирование

Т.е. сначала идут процессы верификации(придумывание идеи проекта)
и тут же придумываются тесты соответствующего уровня абстракции,
потом внизу буквы V - кодирование, затем тестирование по тем тестам, которые составлены на теор. этапе.

Результат: получение проекта гарантированно хорошего качеста.
Система вновь линейна, так что тайм-менеджмент фиксирован.
Хорошо подходит, когда задания хорошо фиксированы(часто применимо в случае Военно-промышл. комплекса).

Минусы:
    - некруто применять модель для малых проектов(пару месяцев).
    - негибкая к изменениям требований походу(т.к. помимо плана нужно менять ещё и тесты даже).

3) Инкрементная модель.
Снова делим разработку на некоторые этапы(инкременты),
где на каждом инкременте добавляется некоторый уровень функциональности.
На каждом этапе не обязательно рабочий продукт.
На каждом этапе:
    - Определение треборваний
    - Проектирование
    - Реализация
    - Внедрение
    - Тестирование
Но суть в том, что содержание инкрементов планируется в самом начале.
Данная модель более толерантна к изменениям, но не полностью - некст лучше(?)

4) Итерационная модель.
Каждый этап - база для следующей итерации.
Важный момент - каждая версия полностью работоспособна.
После выпуска очередной версии - проводим анализ версии и (опционально) собираем фидбэк
для формирования требований и планов для следующей версии.
Вполне толерантна к изменениям.
Итерации стоит делать значительными, чтобы анализ данных не занимал значительную часть времени.
Иногда в одно и то же время происходит сбор фидбека и выпуск новой версии на основе фидбека пред-предыдущей.

5) Спиральная модель.
Большое внимание уделяется рискам.
Внутренние риски - увольнение сотрудника.
Внешние риска - кончилось финансирование.
Bus factor - на сколько замедлится разработка продукта, если ключевого сотрудника собъёт автобус.

Концепция(рисуется спиралью) - делим на этапы, после решения каждой подзадачи оцениваем риски.
Если риски норм, то можем нарастить на нашу улитку новую спираль.

6) RAD - модель.
Rapid Application Development Model - самый быстрый способ решения задачи.
- Делим задачи на модули, которы разрабатывают разные команды.
- Жёстко ограниченное время
- Интеграция отедльных модулей в один проект
- Использование инструментов автоматической сборки и генерации кода

Этапы:
    - Бизнес моделирование
    - Анализ и создание модели данных
    - Анализ и создание моделей процессы 
    - Автоматическая сборка приложения и тестирование

Работает хорошо на несложных идейно проектах, но объёмных технически.

7) Семейство AGILE - гибких метдолгий
- Семейство гибких методолгий разработки
- Короткие итерации
- Разные метрики качества работы
- Много разных конкретных подходов
// AGILE - манифест.
ЛЮДИ и ВЗАИМОДЕЙСТВИЕ важнее процессов и инструментов.
РАБОТАЮЩИЙ ПРОДУКТ важнее документации
СОТРУДНИЧЕСТВО С ЗАКАЗЧИКОМ важнее условий контракта
ГОТОВНОСТЬ К ИЗМЕНЕНИЯМ важнее первоначального плана
// Суть последнего - очень тонкая, т.е. без плана не живём, измнения нужно принимать осторожно и с пониманием.
Суть в том, чтобы откинуть формализм, кажется

SCRUM.
Создаём спринт(1-4 недели).
Создаём Product backlog - что хотим от спринта. Выделяем приоритетные цели(продукт овнер это делает).
Команда выделяет задачи, которые требуются от данного спринта(и каждому выделяется какая-то часть проекта).
Далее спринт и дэйлик каждый день - от каждого разработчика: чо как прошло и какие планы.
Затем после спринта подводим результаты, оценивая загруженность каждого разраба и т.п.

Подходит для малых команд, где легко строить тесное взаимодействие.

KANBAN.
- Делим доску на горизонтальные прямые, где каждая прямая отвечает какой-то команде.
- По вертикали разные статусы выполнения задачи.
- Добавляем карточки(цели) на доску и двигаем их справа налево.
- Цель - двигать цели как можно быстрее в рамках каждой горизонтали.

Подходит для небольших досок, чтобы всё было читаемо.
По легенде - пришло из Тойоты(Япония)
# Про списывание на финальной КР - Бан баллов за сем + пишут служебку в учебное управление

Антипаттерны - типовые косяки(1 лекция)
Разделим на группы
1) В ООП
2) В Кодировании
3) Методологические
4) Управление конфигурацией
5) Прочее

1. ООП.
- Базовый класс утилита
    // т.е. наследование класса DocWriter от FileReader, чтобы получить возможность читать доки
- Anemic Domain Problem
    - боязнь размещать логику в объектах предметной области
    // Т.е. правильно и стоит добавлять члены класса, которые не соответствуют в точности реальному миру
    // но удобны для реализации, напр. Auditory.close(). Хотя на самом деле их кто-то закрывает
- Вызов предка
    - Для реализации функциональности методу протомка приходится вызывать тот же самый метод родителя
    // Т.е. напр. сначала вызовется метод родителя, а потом его return как нибудь декорируется
    // Почему плохо - изменение метода предка ломает методы детей.
    // Решение - разделить наследуемые и не наследуемые объекты точно
- Ошибка пустого подкласса 
    // B: public A. A a(); B b(); , f(a), f(b)
    // f(A& value): if (typeof(value) == A) do(); else doelse();
    // Ожидается одинаковое поведение
- Божественный объект
    // БОльшая часть функциональности данного уровня абстрактности делегирована одному классу
    // Класс Game - распределяет ответсвенность между другими - так вроде можно
- Объектная клоака
    // Переиспользование объектов, находящихся в непригодном для использования состоянии
    // Пример - необходимо удалять настройки прошлого пользователя, когда он вышел из системы принтера
        // перед тем как новый юзер будет использовать Printer.print()
- Полтергейст
    // Объекты, чьё едиснтвенное предназначение - передавать данные другим объектам
    // Но всё-таки бывают случаи, когда это норм - паттерн Медиатор(хотя не совсем туда).
    // Пример Медиатора - самолёты контачат через самолётную вышку
    // Он выполняет некоторую логику по распределению
- Проблем йо-йо
    // Чрезмерная размытость сильно связанного кода по иерархии классов
    // A -> B -> C - классы. Постоянные dynamic_cast и вызовы методов
- Одиночество
    // Неумелое использование Singleton
    // Правильное понимание - когда объект по логике должен быть один и создание второго приведёт к проблемам
    // например - доступ к файлам одновременным
    // Важно, чтобы второй было создать низя
Антипаттерны(2 лекция)
В ООП(продолжение).
    - Приватизация
        Сокрытие функциональности в приватной части, что затрудняет расширение в наследниках
        Open-closed principe запрещает изменение(речь о переносе в нужное время из приватной части в публ.)
        Нужно балансировать между инкапсуляцией и полнотой публичного интерфейса для расширяемости
    - Френд-зона
        Неуместное использование friend (злоупотребление).
        Если 30 френдов обращаются к чему-то в привате, то почему это не в публичном интерфейсе
    - Каша из интерфейсов
        Объединение двух интерфейсов, предварительно разделённых, в один(имеется ввиду сливание, а не 
            наследование класса от неск. интерфейсов)
    - Висящие концы
        Интерфейс, большинство методов которого бессмысленные или являются пустышками.
            // Пример countSmth(): return 0;
        ХУЖЕ сделать функцию пустой, чем НЕ ОБЪЯВИТЬ почти
            Предложение - пустые функции бросают исключение
    - Заглушка
        Попытка натянуть малоподходящий по смыслу интерфейс на класс
        Пример class Music: class Video {} // With no 
        Лучше: class Music: interface Playable {}, class Video: interface Playable, HasVisuals {}

В кодировании.
    - Ненужная сложность
        Использование избыточно сложных решений для тривиальных задач
        "Более сложный код - более ошибкоопасен". (English)
    - Действие на расстоянии
        Взаимодействие между широко разнесёнными частями системы
        Тейк в том, чтобы обращаться к фасаду модуля, а не конкретным классам и реализациям внутри него
    - Накопить и запустить
        Установка параметров подпрограмм в глобальных переменных
        Аргумент 1: Тяжело читаем
        Аргумент 2: Непереносимость модуля(нужно и с глобалами переносить)
    - Слепая вера
        Ситуация, когда после исправления ошибки не проведены все стадии тестировки исправленного куска
    - Лодочный якорь
        Сохранение неиспользуемой части программы
        Хранить код, который никогда не будет использован(пример - драйвера к магнитным дисководам в 2к21)
    - Активное ожидание
        Потребление ресурса в процессе ожидания выполнения запроса, путём выполнения проверок, чтений файлов и.т.д.
        Асинхронного программирование вам в помощь.
        Пример - запросы клиента к серверу раз в 0.001 секунды с ожиданием ответа YES и response.
    - Кэширование ошибки
        Несбрасывания флага ошибки после её обработки.
        Понятно, что плохо
    - Воняющий подгузник
        Сброс флага ошибки без её обработки или передачи на уровень выше
    - Проверка типа вместо интерфейса
        Проверка на специфический тип, вместо требуемого определённого интерфейса
    - Инерация кода
        Избыточное ограничение системы из-за подразумевания постоянной её работы в других частях системы
        Т.е. напр. ограничить качество видео 360р, чтобы это работало и на телефонах с медленным интернетом
    - Кодирование путём исключения
        Добавление нового кода для каждого нового случая
    - Таинственный код
        Использование аббревиатур/сокращений в именах сущностей вместо логичных имён
    - Жёсткое кодирование
        Внедрение предположений в слишком большое количество точек в системе
        Ну короче модуль с малой гибкостью, где пользователь очень ограничен в способностях
    - Мягкое кодирование
        Настраивается вообще всё, что усложняет конфигурирование для пользователя
    Стоит искать баланс между двумя последними пунктами, в зависимости от конкретного потребителя
    - Поток лавы(TODO: сравнить с Лодочным Якорем)
        Сохранение нежелательного кода из-за боязни последствий его удаления/исправления
        Например в API есть ошибка, которую боятся исправлять, т.к. уже овердофига юзеров полагаются
        на именно такое поведение API
        Замечание:
            Иногда имеет смысл, когда есть значительное количество более приоритетных задач
    - Волшебные числа
        Использование числовых констант без объяснения их смысла
        Заводим константу и даём ей осмысленное название. Также легко менять.
    - Процедурный код
        Нафигачили классов, а потом начали использовать исключительно функциональный подход
    - Спагетти-код
        Код с чрезмерно запутанным порядком исполнения
    - Лазанья код (подчёркивает антипаттерн Ненужная сложность)
        Использование неоправданно большого числа уровней абстракции
    - Равиоли-код
        Объекты настолько склеены между собой, что рефакторинг становится невозможным
        Нарушен принцип High cohesion / low coupling
    - Мыльный пузырь
        Объёкт, инициализированный мусором(или не иниц.), который слишком долго ведёт себя как корректный
        Пример - вычисление каких-то параметров объекта только перед тем как они вам понадобятся
            Вопрос(риторический): А вдруг он понадобится кому-то кроме вас до этого, ведь неочев, что поля пустые
    - Мьютексный ад
        Внедрение слишком большого количества примитивов синхронизации в код
        // Используем минимальное количество инструментов, которое нужно, чтобы решить задачу
    - (Мета-)шаблонный рак
        Неадекватное применение шаблонов везде, где это только получилось, а не где это было необходимо
Антипаттерны (часть 3)

Методологические антипаттерны.
- Использование паттернов
    Кто-то считает, что если вы используетее паттерны, значит решаете проблему, а значит что-то уже пошло не так
    Ибо проблемы не должно быть вообще.
- Копирование-вставка
    Когда нужно было написать более общий код. Плохая сторона - тяжело менять, например.
- Дефакторинг
    Процесс уничтожения функциональности и замена её документацией.
    Когда не запилил функционал, но сложил на юзера в документации алгоритм достижения результата.
- Зололтой молоток
    Использование любимого решения везде, где только получилось
- Фактор невероятности
    Гипотеза о том, что известная ошибка не проявится.
    Утв-е: некритичную ошибку отложить на нек. время можно, но в итоге стоит исправить.
- Преждевременная оптимизация
    Оптимизация при недостаточной информации.
    Перед тем, как приступать к оптимизации стоит оценить, какой модуль системы действительно стоит оптимизировать
- Метод подбора
    Софт разрабатывается путём небольших изменений.
    Стоит быть уверенным в своём коде перед тем как его засылать.
- Изобретение велосипеда
    Создание с нуля того, для чего уже есть готовое решение
    Контрпример - иногда можно изобретать свой велосипед, когда существующий - платный(о внешнем софте)
- Изобретение квадратного колеса
    Создание плохого решения, когда существует хорошее.
- Самоуничтожение
    Когда мелкая ошибка приводит к фатальным результатам.
    Стоит правильно проектировать и изолировать подсистемы.
- Два тоннеля
    Необоснованное вынесение новой функциональности в отдельное приложение.
- Коммит - убийца
    Внесение изменений без проерки влияния на другие части программы.
    Система перед выпуском проходит полное тестирование

Управление конфигурацией
- Ад зависимостей. (DLL-hell in Windows)
    Разрастание зависимостей до такого уровня, что раздельная установка программ из пакета становится сложной
    Пример: программы А и Б используют библиотеку Lib. После удаления программы А - удалять поставленную Lib?
        1) Да - ну тогда Б потеряет Lib и перестанет работать
        2) Нет - но пользователь очевидно ожидает удаления(имея ввиду, если Б вдруг не оказалось)
    Пакетные менеджеры(используются в Unix) - решение этой проблемы

Прочие антипаттерны
- Дым и зеркала
    Демонстрация того, как будут работать ненаписанные функции
    Правильным решением подразумевается чёткая документация и реализация строго по ней.
- Раздувание ПО
    Разрешение последующим версиям использовать всё больше и больше ресурсов.
    Пользователь может быть не готов к увеличению потребления ресурсов(финансово) [о бизнес разработке]
- Функции для галочки
    Превращение программы в "сборную солянку" плохо работающих и не связанных между собой функций
    Пример про банковское приложение, присылающее пуши про пробке на районе:)


--- CI/CD ---
Кстати CI / CD / CD

CI - Continious Integration - постоянная интеграция внесённых изменений в существующую систему
    Т.е. автоматизированно: разраб коммитит, затем прогоняются тесты и т.п.
CD - Continious Delivery
    В систему CI добавлена функция собирания release версии, которая в ручную должна быть залита в прод.
CD - Continious Deployment
    Теперь release версия едет автоматически в прод.

Т.е. Это три альтернативы, с разными степенями автоматизации.


--- ПРИМЕР, как это работает у лектора в 1С. -----

1) Этап проектирования
    - Идея
    - Первое обсуждение (сбор команды)
    - Проектный документ (шаблон под него есть, напр.)
        Объективно расскажем чё да как и почему это нужно.
    - Несколько итераций работы над проектным документом
    - Финальное согласование.

2) Этап реализации
    - Отдельная ветка для каждой задачи
    - Локальная реализация и тестирование
    - Поднятие версии - нвн создание версии build-а и компиль проекта?
    - Интеграционная сборка в СI
    - Интеграционная сборка с полными тестами (реальные тесты с эмуляцией кликов, например)

3) Этап сдачи задачи
    - Код ревью
    - Исправление замечаний
    - Документация по задаче
    - Отправка задачи на независимую проверку (сборка + документация)
    - Исправлние замечание
    - Получение финального разрешения на влития ветки в ствол.
    - Влитие и закрытие задачи.

4) Подготовка к выпуску версии
    - Введение моратория на разработку (во время моратория запрещено заниматься разработкой непоср-но)
    - Проверка "висящих" задач
    - Влитие оставшихся задач
    - Введение моратория на изменения в ствол
    - Сборка кандидата в релиз
    - Тестирование (автом. и ручное)
    - Исправление ошибок, повтор тестирования
    - Релиз кандидата
Замечание: моратории могут и не вводиться для минорных версий
    
QA - Управление качеством ПО

Специалист по QA - возможная профессия
Узкая востр. специальность, интересные задачи, низкая конкуренция

Что такое качество ПО? // Неформально - то, что обеспечивается тестированием
Качество ПО - способность программного продукта при заданных условиях удовлетворять
    установленным или предполагаемым потребностям (ISO - стандарт как ГОСТ, например)

Основные аспекты качества ПО по ISO 9126.
    - Софт разрабатываем - введение метрик качества процесса
    - Внутреннее качество - оценка характеристики софта, с точки зрения реализации
    - Внешнее качество - как софт выглядит с точки зрения пользователя (как концепт?)
    - Конечное качество - при использовании в конкретных контекстах.

Характеристики и атрибуты качества ПО по ISO 9126.
    - Функциональность
    - Функциональная пригодность - решает ли софт поставленную задачу в заявленном объёме
    - Соответствие стандартам - например обеспечение безопасности при работе с перс. данными
    - Защищённость - имея ввиду что пользователь не положит серв, напр.
    - Удобство использования
        - Привлекательность
        - User Experience
    - Понятность (с точки зрения пользователя)
    - Удобство обучения
    - Производительность и ресурсоэффективность
    - Удобство сопровождения / Анализируемость (пример - логирование)
    - Переносимость - адаптируемость к другому железу, возможность перехода на ваш софт
    - Удобство установки

Согласно ГОСТу:
    Весь объём признаков и характеристик программ, который относится к их способности
        удовлетворять установленным или предполагаемым потребностям

Согласно IEEE Std:
    Степень, в которой система, компонент или процесс удовлетворяет потребностям или ожиданиям
        заказчика или пользователя

Парадокс тестировщика:
    С одной стороны, ему платят за то, чтобы получить уверенность при выпуске продукта
    С другой стороны, находя проблемы и ошибки, он повышает неуверенность

Соответствие по ожиданиям stakeholder-ов(представитель бизнеса):
    - Отсутствие финансовых рисков
    - Ключевые клиенты довольны (которые приносят прибыль, например)
    - Качество продукта в разрезе внешних ошибок
    - Степень автоматизации тестирования
    - Эффективность [авто]тестирования
    - .... Ожидания stakeholder-ов не упираются в какую-то конкр. хар-ку, могут быть разнообразны

Ещё прикол:
    Отсутствие жалоб на качество парашютов ещё не значит, что они сделаны правильно.
    - На неиспользуемом софте не находят ошибки


Качество и деньги.
    Десятичное правило стоимости качества
    - Чем позже найдена проблема, тем дороже обходится её решение.
    Маркетинг 0.1, Проектирование 1, Подготовка производства 10, Изготовление 100, Эксплуатация 1000
    Причём число 10 на каждом этапе научно обоснованно.

    - Могут быть компенсации клиентам за ошибки в ПО
        *Иногда это стоит дороже проесса разработки, так что некоторые процессы не доходят до релиза и закрываются
    - Клиенты могут платить отдельные деньги за обеспечение качества их бизнесс-процессов
    - "Качественный продукт можно продавать дороже"
    - Быстро, Хорошо и Дорого не бывает:)

Ручное тестирование:
1) Классификация: ручная и автоматическая
2) Классификация: Black-box и White-box.
    BB - тестирование в нек. смысле публичного интерфейса
    WB - тестирование софта, внутренних его частей, залезая в его реализацию и детали

Опр. Класс эквивалентности - набор данных, обрабатываемый одинаковым образом и приводящих к одинак. результату
Опр. Граничные значения - значения, находящиеся на границах классов эквивалентности
    Проверка граничных значений может быть наиболее эффективна.

--- 7 ключевых инструментов контроля качества(набор тестировщика): ---
1) Причинно-следственная диаграмма Исикавы (Ишикавы)
    Справа - получившаяся проблема.
    Слева - дерево причин - что могло повлиять на появление этой проблемы.
        (каждую группу причин прорабатываем и выделяем наиболее вероятные)

2) Блок-схема
    - Применяется в планировании и контроле.
        Разделяем дефолт б-с горизонтально на регионы ответственности того или иного объекта кода и т.п.

3) Контрольный листок
    Концепция - считать количество ошибочных действий в том или ином сегменте по отрезкам времени.
    Пример: в четверг на производстве шин было допущено 2 измерительных ошибки.

4) Контрольная карта (карта Шухарта)
    - Построение графика контрольной величины (ОY - величина, ОХ - время)
    - Поиск разрешённых границ (Specification limit)
    - Поиск желательных границ (Control limit)
    - Медиана (серидин разр. границ)
    - Анализ графика:
        Правило 7: если >=7 точек лежит вдоль одной горизонтали, но не медианы, стоит задуматься почему
    - Control limit нужен, чтобы вовремя успеть разобраться с проблемами до выхода за Spec. limit.
Контрольная 13 мая - по всему лекционному материалу.
QA - вторая часть.
Продолжаем изучать 7 ключевых инструментов.

5) Гистограмма
    - Позволяет что-то удобно проиллюстрировать
    - Гибкий инструмент, т.е. широкая область применения.

6) Диаграмма Парето
    - Правило Парето(правило 80 / 20):
        - 20 процентов клиентов приносят 80 процентов денег
        - 20 проентов ошибок приводят к 80 процентам проблем
    - Внешний вид:
        Строим гистограмму, сортируем столбики по высоте (высота - в процентах)
        Далее строим прямую, которая высотой префиксной сумм.
        // Т.е. складываем по очереди процентные значения столбиков и строим выпуклую кривую
    - Полезно строить в разные моменты времени

7) Диаграмма разбрасывания
    - Кореляция величин - наличие связи/зависимости между величинами
    - Внешний вид:
    Плоскость XOY, где каждой оси соспоставлена величина.
    Далее производим измерения обеих величин в разные моменты времени и отмечаем соотв. точки (x, y) на пл-ти
    Далее два варианта:
        1) Просматривается какая-то картинка / сгруппированность(кластеры) и т.п.
        2) Распределение точек по плоскости примерно равномерное
    - Иногда полезно искать корреляцию двух внешних показателей.

Ручное тестирование - Практика
    - Во всех компаниях - чек-листы, тест-планы, тест-сьюты(наборы тестовых кейсов), тест-кейсы
        Определённые документы, чтобы производить грамотное тестирование.
    - Ручное тестирование в обозримом будущем не будет заменено автоматизированным:
        - Исследовательское тестирование человек делает лучше.
        - Тестирование своего кода - пожалуй, лучший способ повысить его качество.
    - Может быть:
        - Проверка соответствия спецификации(документации/ТЗ в т.ч.)
        - Ручное тестирование перед автоматическим
        - Ручное тестирование(детализированное, напр.) и автоматическое параллельно
    - Сколько автотесты занимают для больших продуктов: *часы*


Автоматизированное тестирование - теория
    - Чем автоматизированное тестирование лучше ручного:
        - Позволяет быстрее находить ошибки
        - Цикл тестирования гораздо дешевле
    - Чем ручное тестирование лучше автоматизированного:
        - Эффективнее
        - Более гибкое
    - Тестирование нужно начинать с ручных сессий! Далее, когда сессии тестирования начнут повторяться,
    стоимость автоматизации и планируемое количество сессий подскажут, что нужно автоматизировать в первую очередь
    - Идеальная ситуация - когда используется эффективная комбинация ручного и автоматизированного тестирования

Жизненный цикл автотеста:
    - Создание теста 
    - Проверка и отладка теста
    - Встраивание теста в прогон автотестов
    - Удаление теста из инфраструктуры

Автоматизированное тестирование - Практика:
    - Автотесты - это не только автоматизация ручных тестов
        - Они могут быть более комплексными и объёмными
    - Разработка автоматизации тестирования - это полноценная разработка ПО(в том числе тесты для тестов и др.)
    - При написании автотестов нужно следовать стандартам и идиомам.
    - Помните о затратах на внедрение автотестов и их обслуживание
    - Тесты следует делать независимыми друг от друга.
    - Логирование и отчёты следует вводить с самого начала (логирование для системы автотестов)
    - Тестируемость и автоматизируемость продукта с самого начала
    - Не попадайте в ловушку невозвратных затрат
        - Напр: не стоит писать автотесты, если проверка валидности результата требует глаза человека.
    - Посмотрите не существует ли готовых аналогов.
    - Никогда не делайте тестовые данные зависимыми от времени.
        Тест - некоторый закрытый мир, который не берёт данные из внешнего мира.
    
Как бывает на практике:
    - У компании свой фраемворк для тестирования(самописный, основанный на чём-то)
    - Гигантские мощности в датацентрах для автотестирования
    - И даже "старые" компы и компы разработчиков по ночам!

Роль CI/CD.
    Ну вы сами знаете что это и как работает:
    - Developer: push
    - gitHub: вызывает CI-машину
    - CI-машина: прогоняет тесты и оповещает разработчика о результатах теста, предоставляет артефакты
    - Developer: сделал выводы
    
